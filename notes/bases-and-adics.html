<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>Bases & Adics — Leo Shabarov</title>
<link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;700&display=swap" rel="stylesheet">
<style>
/* ---------- theme ---------- */
*{box-sizing:border-box;margin:0;padding:0}
:root{--ink:#eaf1ff;--muted:#a8b4d9;--line:#1a1f36;--bg:#070913;--g1:#6ee7ff;--g2:#8b5cf6}
html,body{height:100%}
body{font-family:'Space Grotesk',system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--ink)}
a{color:inherit;text-decoration:none}
.header{position:sticky;top:0;z-index:10;background:linear-gradient(180deg,rgba(7,9,19,.9),rgba(7,9,19,.65) 70%,transparent);backdrop-filter:blur(10px);border-bottom:1px solid #121630}
.nav{max-width:980px;margin:0 auto;padding:14px 18px;display:flex;align-items:center;justify-content:space-between}
.brand{display:flex;gap:.7rem;align-items:center}
.logo{width:40px;height:40px;border-radius:12px;background:conic-gradient(from var(--rot,0deg),var(--g1),var(--g2),#4dd4ff,#a78bfa,var(--g1));display:grid;place-items:center;box-shadow:0 10px 30px #0009}
.wrap{max-width:900px;margin:0 auto;padding:32px 18px 80px}
.h1{font-size:clamp(2.2rem,5.5vw,3.6rem);line-height:1.04;letter-spacing:-.01em}
.subtitle{color:var(--muted);margin-top:8px}
.footer{max-width:980px;margin:40px auto 28px;padding:0 18px;color:#91a1d6;display:flex;justify-content:space-between;align-items:center}

/* ---------- reading rhythm ---------- */
.prose{font-size:clamp(1.05rem,2.2vw,1.18rem);line-height:1.75;margin-top:20px}
.prose p+p{margin-top:1rem}
.prose h2{display:flex;align-items:center;gap:.6rem;font-size:clamp(1.5rem,3vw,1.9rem);margin:38px 0 10px}
.tag{display:inline-grid;place-items:center;width:28px;height:28px;border-radius:10px;background:#0c1130;border:1px solid #222a5a;color:#bcd1ff;font-weight:800}
.hr{height:1px;background:linear-gradient(90deg,transparent,#1a2145,transparent);margin:36px 0}

/* ---------- panels & canvas ---------- */
.panel{margin:16px 0;border:1px solid #1a2040;border-radius:16px;background:linear-gradient(180deg,#0a0f26,#090c1e);box-shadow:0 14px 32px #0009}
.panel .row{display:flex;flex-wrap:wrap;gap:10px;padding:14px}
.input{flex:1 1 240px;display:flex;align-items:center;gap:8px;border:1px solid #232a55;background:#0d1330;border-radius:12px;padding:10px 12px}
.input input,.input select{flex:1;font:inherit;background:transparent;color:var(--ink);border:0;outline:0}
.input .mono{opacity:.75}
.canvasbox{border-top:1px dashed #1b2246;overflow:hidden}
.canvasbox canvas{display:block;width:100%;height:260px}
.small{height:200px}
.note{margin:10px 16px;padding:12px 14px;border:1px dashed #26306a;border-radius:12px;color:#c9d6ff;background:linear-gradient(180deg,#0b1024,#090e20)}

/* ---------- motion polish ---------- */
.fade{opacity:0;transform:translateY(10px);transition:opacity .6s,transform .6s}
.fade.on{opacity:1;transform:none}

/* ---------- helpers ---------- */
.inline{display:inline-block;padding:.12rem .5rem;border-radius:999px;background:#0d1330;border:1px solid #232a55;font-weight:700}
.center{text-align:center}
.kbd{font-weight:700;background:#0e1227;border:1px solid #1a2040;padding:.1rem .4rem;border-radius:6px}
</style>
</head>
<body>
<header class="header">
  <div class="nav">
    <a href="/" class="brand"><div class="logo"><svg width="18" height="18" viewBox="0 0 24 24"><path fill="#fff" d="M12 2l2.8 6.6L22 9.3l-5 4.6L18.6 21 12 17.7 5.4 21 7 13.9 2 9.3l7.2-.7z"/></svg></div><strong>Leo Shabarov</strong></a>
    <a href="/#notes">Notebook</a>
  </div>
</header>

<main class="wrap">
  <section class="fade on">
    <div class="inline">Guide</div>
    <h1 class="h1">Bases & Adics</h1>
    <p class="subtitle">A visual walkthrough of place-value, conversions, and why \( \ldots 9999_{10} = -1 \) makes perfect sense—p-adically.</p>
  </section>

  <!-- 1) Why 2+2 can be 10 or 100 -->
  <section class="prose fade">
    <h2><span class="tag">1</span> Why \(2+2\) can be \(10\) or \(100\)</h2>
    <p>In base \(10\): \(2+2=4\). In base \(4\), the digit “4” doesn’t exist—next place is “\(10\)”, so \(2+2=10_4\). In base \(2\), \(4_{10}=100_2\), hence \(2+2=100_2\). In base \(3\), \(4_{10}=11_3\), so \(2+2=11_3\). <em>Symbols and carries depend on the base.</em></p>

    <div class="panel" id="carryDemoPanel">
      <div class="row">
        <div class="input"><span class="mono">base</span>
          <input type="range" id="carryBase" min="2" max="12" value="2" />
          <span id="carryBaseVal">2</span>
        </div>
        <div class="note">Watch \(2+2\) roll over as the base changes. The carry pops exactly at the base threshold.</div>
      </div>
      <div class="canvasbox"><canvas id="carryDemo"></canvas></div>
    </div>

    <div class="hr"></div>
  </section>

  <!-- 2) What a base is + place-value ruler -->
  <section class="prose fade">
    <h2><span class="tag">2</span> What a base is</h2>
    <p>A base \(b\) is two things at once: the size of your digit alphabet \(0,1,\dots,b\!-\!1\), and the values of places \(b^0,b^1,b^2,\dots\) growing to the left. Example (base \(7\)): \(351_7=3\cdot7^2+5\cdot7^1+1\cdot7^0=183\).</p>

    <div class="panel">
      <div class="row">
        <div class="input"><span class="mono">base</span><input id="rulerBase" type="range" min="2" max="16" value="7"><span id="rulerBaseVal">7</span></div>
        <div class="input"><span class="mono">digits</span><input id="rulerDigits" value="351" spellcheck="false"></div>
      </div>
      <div class="canvasbox"><canvas id="ruler"></canvas></div>
    </div>

    <div class="hr"></div>
  </section>

  <!-- 3) Read any base to decimal -->
  <section class="prose fade">
    <h2><span class="tag">3</span> Reading any base back to decimal</h2>
    <p>For \(a_ka_{k-1}\dots a_1a_0\) in base \(b\): \(\;a_0b^0+a_1b^1+a_2b^2+\cdots+a_kb^k\). For instance \(1004_7=347_{10}\).</p>
  </section>

  <!-- 4) Decimal to base b (remainders) -->
  <section class="prose fade">
    <h2><span class="tag">4</span> Converting a decimal integer to base \(b\)</h2>
    <p>Repeatedly divide by \(b\) and record remainders. Those remainders (read in reverse) are your digits.</p>

    <div class="panel">
      <div class="row">
        <div class="input"><span class="mono">n</span><input id="divN" value="347"></div>
        <div class="input"><span class="mono">base</span><input id="divB" type="number" min="2" max="36" value="7"></div>
        <div class="note">Digits push to a stack; then the stack reverses into the numeral.</div>
      </div>
      <div class="canvasbox"><canvas id="divCanvas"></canvas></div>
    </div>

    <div class="hr"></div>
  </section>

  <!-- 5) Fractional parts (multiply by b) -->
  <section class="prose fade">
    <h2><span class="tag">5</span> Converting fractional parts</h2>
    <p>Multiply the fraction by \(b\); the integer part each time is the next digit. Some fractions terminate in some bases and repeat in others. A reduced fraction terminates in base \(b\) iff its denominator’s prime factors all divide \(b\).</p>

    <div class="panel">
      <div class="row">
        <div class="input"><span class="mono">fraction</span><input id="fracIn" value="0.625"></div>
        <div class="input"><span class="mono">base</span><input id="fracB" type="number" min="2" max="16" value="2"></div>
        <div class="note">Bar scales by \(b\); a digit pops out at each step.</div>
      </div>
      <div class="canvasbox small"><canvas id="fracCanvas"></canvas></div>
    </div>

    <div class="hr"></div>
  </section>

  <!-- 6) Addition & multiplication -->
  <section class="prose fade">
    <h2><span class="tag">6</span> Adding & multiplying in other bases</h2>
    <p>Same column rules; the carry threshold is \(b\) instead of \(10\). Example (base \(7\)): \(256_7+345_7=634_7\). Example (base \(3\)): \(12_3\times21_3=1022_3\).</p>

    <div class="panel">
      <div class="row">
        <div class="input"><span class="mono">base</span><input id="arithB" type="range" min="2" max="12" value="7"><span id="arithBVal">7</span></div>
        <div class="input"><span class="mono">A</span><input id="arithA" value="256"></div>
        <div class="input"><span class="mono">B</span><input id="arithC" value="345"></div>
        <div class="note">Toggle between <span class="kbd">+</span> and <span class="kbd">×</span>:</div>
        <div class="input" style="flex:0 0 auto"><select id="arithOp"><option value="add">A + B</option><option value="mul">A × B</option></select></div>
      </div>
      <div class="canvasbox"><canvas id="arithCanvas"></canvas></div>
    </div>

    <div class="hr"></div>
  </section>

  <!-- 7) Quick base facts -->
  <section class="prose fade">
    <h2><span class="tag">7</span> Quick base facts you will use later</h2>
    <p>Divisible by \(b\) iff the last digit in base \(b\) is \(0\). The last \(k\) digits determine the value modulo \(b^k\). Changing base changes symbols, not quantity.</p>
    <div class="panel">
      <div class="row">
        <div class="input"><span class="mono">b</span><input id="modB" type="number" min="2" max="16" value="10"></div>
        <div class="input"><span class="mono">k</span><input id="modK" type="number" min="1" max="8" value="3"></div>
        <div class="input"><span class="mono">n</span><input id="modN" value="1234567"></div>
      </div>
      <div class="canvasbox small"><canvas id="modCanvas"></canvas></div>
    </div>

    <div class="hr"></div>
  </section>

  <!-- 8) From bases to adic thinking -->
  <section class="prose fade">
    <h2><span class="tag">8</span> From bases to adic thinking</h2>
    <p>p-adics flip “closeness”: two integers are close if their last digits agree in base \(p\). Infinite expansions run to the left. That’s why \( \ldots 9999_{10} = -1 \) (add one: carries wipe all 9s).</p>

    <div class="panel">
      <div class="row"><div class="note">Infinite-carry demo: \( \ldots 9999 + 1 \to \ldots 0000 \).</div></div>
      <div class="canvasbox"><canvas id="infCarry"></canvas></div>
    </div>

    <div class="hr"></div>
  </section>

  <!-- 9) Building b-adic integers; 10) p-adic abs value; 12) p-adic series -->
  <section class="prose fade">
    <h2><span class="tag">9</span> Building \(b\)-adic integers</h2>
    <p>Either choose digits \(a_0,a_1,\dots\in\{0,\dots,b-1\}\) and form \(a_0+a_1b+a_2b^2+\cdots\) (converges adically), or choose compatible remainders \(x_n \bmod b^n\) with \(x_{n+1}\equiv x_n \ (\bmod\ b^n)\).</p>

    <h2><span class="tag">10</span> Prime bases & the p-adic absolute value</h2>
    <p>\(v_p(n)\) is the exponent of \(p\) in \(n\); define \(|n|_p=p^{-v_p(n)}\) (\(|0|_p=0\)). Then \(d_p(x,y)=|x-y|_p\) and \(|x+y|_p\le \max(|x|_p,|y|_p)\).</p>

    <div class="panel">
      <div class="row">
        <div class="input"><span class="mono">p</span><input id="pVal" type="number" min="2" max="11" value="2"></div>
        <div class="note">Watch the geometric series \(1+p+p^2+\cdots\) get <em>closer</em> p-adically to a limit.</div>
      </div>
      <div class="canvasbox small"><canvas id="pSeries"></canvas></div>
    </div>

    <div class="hr"></div>
  </section>

  <!-- 11) Qp/Zp, 13) Zp arithmetic, 14) Hensel, 15) non-prime b (CRT), 16-20 text-only (tight) -->
  <section class="prose fade">
    <h2><span class="tag">11</span> Completing to \( \mathbb{Q}_p \) and \( \mathbb{Z}_p \)</h2>
    <p>Complete \( \mathbb{Q} \) under \(d_p\) to get \( \mathbb{Q}_p \). The p-adic integers \( \mathbb{Z}_p \) are those with \(|x|_p\le1\) (no negative powers). Every \(x\in\mathbb{Q}_p\) is \(p^k\cdot u\) with \(k\in\mathbb{Z}\) and unit \(u\in\mathbb{Z}_p\) (first digit nonzero mod \(p\)).</p>

    <h2><span class="tag">12</span> Series that converge p-adically but not in reals</h2>
    <p>\(1+p+p^2+\dots=\frac{1}{1-p}\) because \(|p|_p<1\). Example in \(2\)-adics: \(1+2+4+8+\cdots=-1\). In \(10\)-adics: \(1+10+100+\cdots=-\tfrac19\).</p>

    <h2><span class="tag">13</span> Doing arithmetic in \( \mathbb{Z}_p \)</h2>
    <p>Column rules still work; each column sees finitely many carries. Units are the numbers with first digit \(\not\equiv0 \pmod p\). Inverses come from successive lifting (solve mod \(p\), then mod \(p^2\), etc.).</p>

    <h2><span class="tag">14</span> Hensel’s lemma (idea)</h2>
    <p>If \(f(a)\equiv0\pmod p\) and \(f'(a)\not\equiv0\pmod p\), there’s a unique root \(x\in\mathbb{Z}_p\) with \(x\equiv a\pmod p\), obtained by lifting (Newton in \( \mathbb{Z}_p \)).</p>

    <h2><span class="tag">15</span> When \(b\) isn’t prime</h2>
    <p>If \(b=\prod p_i^{e_i}\), then \( \mathbb{Z}_b \cong \prod \mathbb{Z}_{p_i} \) (Chinese Remainder Theorem intuition: “last \(k\) digits in base \(b\)” means last \(k\) digits in each \(p_i\)-power).</p>

    <h2><span class="tag">16</span> Uses</h2>
    <p>Divisibility/carries; lifting congruences; local obstructions to Diophantine equations; fast p-adic Newton; foundations for local-to-global methods and p-adic analysis.</p>

    <h2><span class="tag">17</span> “How to” moves</h2>
    <p>Convert bases; add/multiply with carry \(b\); compute \(v_p\) and \(|\cdot|_p\); spot p-adic convergence; invert units by lifting; apply Hensel given a good seed.</p>

    <h2><span class="tag">18</span> Mini-examples</h2>
    <p><strong>A.</strong> \(1+2+4+\cdots=-1\) in \(2\)-adics: partial sums \(2^{k+1}-1\) differ from \(-1\) by \(2^{k+1}\) whose size is \(2^{-(k+1)}\to0\).<br>
       <strong>B.</strong> \(-1=\ldots 9999_{10}\).<br>
       <strong>C.</strong> Inverse of \(7\) in \(2\)-adics: start at \(1\) mod \(2\), lift upward.<br>
       <strong>D.</strong> \(1+10+100+\cdots=-\tfrac19\) in \(10\)-adics.</p>

    <h2><span class="tag">19</span> Practice (quick)</h2>
    <p>Try: convert \(987_{10}\to\) base \(8\); convert \(0.2_{10}\to\) base \(5\); compute \(456_7+351_7\); find \(v_3(540)\) and \(|540|_3\); first three base-\(5\) digits of \(1/2\) in \(5\)-adics; show \(1+5+25+\cdots=-\tfrac14\) in \(5\)-adics; lift a solution of \(x^2\equiv1\pmod5\); explain \( \mathbb{Z}_{10}\cong \mathbb{Z}_2\times\mathbb{Z}_5\).</p>
  </section>
</main>

<footer class="footer">
  <div>© <span id="year"></span> Leo Shabarov</div>
  <a href="/">Back to home</a>
</footer>

<!-- ---------- scripts: layout + animations ---------- -->
<script>
/* accent rotation (matches home vibe) */
let rr=0;setInterval(()=>{rr=(rr+3)%360;document.documentElement.style.setProperty('--rot',rr+'deg')},60)

/* small fade-in on scroll */
const io=new IntersectionObserver(es=>{for(const e of es){if(e.isIntersecting)e.target.classList.add('on')}},{threshold:.15})
document.querySelectorAll('.fade').forEach(el=>io.observe(el))
document.getElementById('year').textContent=new Date().getFullYear()

/* helpers */
const mapDigits='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x))

function toBaseStrBig(n,b){
  let x = BigInt(n);
  const B = BigInt(b);
  const neg = x<0n; if(neg) x=-x;
  if(x===0n) return '0';
  let s='';
  while(x>0n){ const r=Number(x%B); s=mapDigits[r]+s; x/=B; }
  return neg?'-'+s:s;
}
function parseBigInBase(str,b){
  const s=str.trim(); if(!s) return 0n;
  const neg = s[0]==='-'?1:0; const digs=s.slice(neg?1:0).toUpperCase();
  let val=0n; const B=BigInt(b);
  for(const ch of digs){ const v=BigInt(mapDigits.indexOf(ch)); if(v<0n||v>=B) return NaN; val=val*B+v; }
  return neg?-val:val;
}

/* 1) carry demo for 2+2 across bases */
const carryDemo=document.getElementById('carryDemo'), carryBase=document.getElementById('carryBase'), carryBaseVal=document.getElementById('carryBaseVal')
function drawCarry(){
  const ctx=carryDemo.getContext('2d')
  const dpr=Math.min(devicePixelRatio||1,2), W=carryDemo.clientWidth||720, H=260
  carryDemo.width=W*dpr; carryDemo.height=H*dpr; ctx.setTransform(dpr,0,0,dpr,0,0)
  ctx.clearRect(0,0,W,H)

  const b=parseInt(carryBase.value); carryBaseVal.textContent=b
  // count strip
  const digits=[...Array(b).keys()]
  const cx=W/2, cy=H/2-34, w=Math.min(46, Math.max(26, W/(b+6)))
  ctx.font='14px Space Grotesk'; ctx.textAlign='center'; ctx.textBaseline='middle'
  digits.forEach((d,i)=>{
    const x=cx-(digits.length-1)*w/2+i*w, y=cy
    ctx.fillStyle='rgba(255,255,255,.08)'; ctx.fillRect(x-16,y-16,32,32)
    ctx.strokeStyle='rgba(255,255,255,.15)'; ctx.strokeRect(x-16,y-16,32,32)
    ctx.fillStyle='#eaf1ff'; ctx.fillText(String(d),x,y)
  })

  // 2 + 2 animation
  const t=(performance.now()/1000)%2
  const k=(t<1)?t:(2-t)
  const carryH=Math.max(0, Math.min(1, (2+b-4)/b)) // carry happens for b<=4; still animate bubble softly otherwise
  const sum=4, rollover=sum>=b
  const ones = rollover? sum-b : sum
  const left = rollover? 1 : 0

  // ones column
  const ox=cx, oy=H/2+18
  ctx.fillStyle='#cfe2ff'; ctx.fillText('2',ox-36,oy-22)
  ctx.fillText('+ 2',ox-36,oy)
  ctx.fillStyle='#a8b4d9'; ctx.fillText('—',ox-36,oy+10)

  // carry bubble
  if(rollover){
    const by=oy-48-10*Math.sin(k*Math.PI)
    ctx.beginPath(); ctx.fillStyle='rgba(110,231,255,.22)'
    ctx.arc(ox+32,by,12+6*k,0,Math.PI*2); ctx.fill()
    ctx.strokeStyle='rgba(110,231,255,.7)'; ctx.stroke()
    ctx.fillStyle='#aee7ff'; ctx.font='12px Space Grotesk'; ctx.fillText('carry',ox+32,by)
  }

  // result digits
  ctx.font='22px Space Grotesk'; ctx.fillStyle='#ffd7aa'
  const res = rollover ? `${left}0` : `${ones}`
  const show = rollover ? `${ones}  (mod ${b})` : `${ones}`
  ctx.fillText(`= ${show}`,ox+36,oy+2)

  // final line
  ctx.fillStyle='#eaf1ff'; ctx.font='18px Space Grotesk'
  const target = rollover? (b===2?'100₂': b===3?'11₃': b===4?'10₄': `1·${b}+0`) : (b===10?'4₁₀': String(ones))
  ctx.fillText(`So 2 + 2 = ${target}`, cx, H-28)
}
carryBase.addEventListener('input',drawCarry)

/* 2) place-value ruler */
const ruler=document.getElementById('ruler'), rulerBase=document.getElementById('rulerBase'), rulerDigits=document.getElementById('rulerDigits'), rulerBaseVal=document.getElementById('rulerBaseVal')
function drawRuler(){
  const ctx=ruler.getContext('2d')
  const dpr=Math.min(devicePixelRatio||1,2), W=ruler.clientWidth||720, H=260
  ruler.width=W*dpr; ruler.height=H*dpr; ctx.setTransform(dpr,0,0,dpr,0,0)
  ctx.clearRect(0,0,W,H)
  const b=parseInt(rulerBase.value); rulerBaseVal.textContent=b
  const digs=(rulerDigits.value||'0').trim().toUpperCase()
  const vals=[...digs].map(ch=>mapDigits.indexOf(ch)).reverse()
  const cx=W/2, baseline=H/2+20, step=Math.min(80, Math.max(50, W/(vals.length+2)))
  ctx.textAlign='center'; ctx.textBaseline='middle'

  // beads & powers
  for(let i=0;i<vals.length;i++){
    const x=cx+(i-(vals.length-1)/2)*step
    ctx.fillStyle='rgba(255,255,255,.1)'; ctx.fillRect(x-22,baseline-40,44,80)
    ctx.strokeStyle='rgba(255,255,255,.15)'; ctx.strokeRect(x-22,baseline-40,44,80)
    // bead
    const ty = baseline-22 - 16*Math.sin((performance.now()/1000 + i)*0.8)
    ctx.beginPath(); ctx.fillStyle='rgba(170,210,255,.9)'; ctx.arc(x,ty,14,0,Math.PI*2); ctx.fill()
    ctx.fillStyle='#0b0f24'; ctx.font='14px Space Grotesk'; ctx.fillText(String(vals[i]),x,ty)

    // labels
    ctx.fillStyle='#c1cced'; ctx.font='12px Space Grotesk'
    ctx.fillText(`× ${b}^${i}`,x,baseline+34)
  }

  // sum
  const value=vals.reduce((acc,vi,idx)=>acc + vi*Math.pow(b,idx),0)
  ctx.fillStyle='#eaf1ff'; ctx.font='18px Space Grotesk'
  ctx.fillText(`${digs}_{${b}} = ${value}_{10}`, cx, 28)
}

/* 4) division remainder stack */
const divCanvas=document.getElementById('divCanvas'), divN=document.getElementById('divN'), divB=document.getElementById('divB')
function drawDiv(){
  const ctx=divCanvas.getContext('2d')
  const dpr=Math.min(devicePixelRatio||1,2), W=divCanvas.clientWidth||720, H=260
  divCanvas.width=W*dpr; divCanvas.height=H*dpr; ctx.setTransform(dpr,0,0,dpr,0,0)
  ctx.clearRect(0,0,W,H)
  const n=parseInt(divN.value||0), b=clamp(parseInt(divB.value||10),2,36)
  divB.value=b

  // compute steps
  let x=n, rows=[]
  for(let i=0;i<24 && x>0;i++){ const q=Math.floor(x/b), r=x%b; rows.push({x,q,r}); x=q }
  if(rows.length===0) rows.push({x:0,q:0,r:0})
  const stack=rows.map(r=>r.r)
  const digits=[...stack].reverse().map(d=>mapDigits[d]).join('')

  // draw table
  const left=28, col=[left, W/2, W-88], y0=60
  ctx.fillStyle='#c1cced'; ctx.font='12px Space Grotesk'
  ctx.fillText('value',col[0],32); ctx.fillText(`divide by base ${b}`,col[1],32); ctx.fillText('remainder',col[2],32)
  ctx.strokeStyle='rgba(255,255,255,.12)'; ctx.strokeRect(10,10,W-20,H-20)

  ctx.fillStyle='#eaf1ff'; ctx.font='14px Space Grotesk'
  let y=y0
  for(const r of rows){
    ctx.fillText(String(r.x),col[0],y)
    ctx.fillText(String(r.q),col[1],y)
    ctx.fillText(String(r.r),col[2],y)
    y+=18
  }

  // stack animation (flip-up)
  const t=(performance.now()/1000)%2, k=Math.min(1, t)
  const sx=W/2, sy=H-36
  ctx.save()
  ctx.translate(sx,sy)
  for(let i=0;i<stack.length;i++){
    const up=i*18*k
    ctx.globalAlpha=0.85
    ctx.fillStyle='rgba(110,231,255,.22)'; ctx.fillRect(-26,-8-up,52,16)
    ctx.globalAlpha=1
    ctx.fillStyle='#aee7ff'; ctx.fillText(String(stack[i]),0,-up)
  }
  ctx.restore()

  ctx.fillStyle='#ffd7aa'; ctx.font='18px Space Grotesk'
  ctx.fillText(`${n}_{10} = ${digits||'0'}_{${b}}`, W/2, H-10)
}

/* 5) fractional digit peeling */
const fracCanvas=document.getElementById('fracCanvas'), fracIn=document.getElementById('fracIn'), fracB=document.getElementById('fracB')
function drawFrac(){
  const ctx=fracCanvas.getContext('2d')
  const dpr=Math.min(devicePixelRatio||1,2), W=fracCanvas.clientWidth||720, H=200
  fracCanvas.width=W*dpr; fracCanvas.height=H*dpr; ctx.setTransform(dpr,0,0,dpr,0,0)
  ctx.clearRect(0,0,W,H)
  let f=parseFloat(fracIn.value||0); if(!(f>=0&&f<1)) f=0.625
  const b=clamp(parseInt(fracB.value||2),2,16); fracB.value=b

  // bar
  const L= W-120, x0=60, y=H/2
  ctx.strokeStyle='rgba(255,255,255,.2)'
  ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x0+L,y); ctx.stroke()
  ctx.fillStyle='rgba(170,210,255,.18)'; ctx.fillRect(x0,y-12,L,24)

  // simulate a few steps
  let x=f, digs=[], steps=6
  for(let i=0;i<steps;i++){
    x*=b; const d=Math.floor(x); digs.push(d); x-=d
  }
  // animated head
  const t=(performance.now()/1000)%1, head=x0 + L*(f + t*(Math.min(1,f*b)-f))
  ctx.fillStyle='rgba(110,231,255,.4)'; ctx.fillRect(x0,y-12,L*f,24)
  ctx.fillStyle='#aee7ff'; ctx.font='14px Space Grotesk'
  ctx.fillText(`digits: .${digs.map(d=>mapDigits[d]).join('')}_${b}`, W/2, y+44)

  // head dot
  ctx.beginPath(); ctx.fillStyle='#cfe2ff'; ctx.arc(x0+L*f, y, 6, 0, Math.PI*2); ctx.fill()
}

/* 6) addition / multiplication columns */
const arithCanvas=document.getElementById('arithCanvas'), arithB=document.getElementById('arithB'), arithBVal=document.getElementById('arithBVal'), arithA=document.getElementById('arithA'), arithC=document.getElementById('arithC'), arithOp=document.getElementById('arithOp')
function drawArith(){
  const ctx=arithCanvas.getContext('2d')
  const dpr=Math.min(devicePixelRatio||1,2), W=arithCanvas.clientWidth||720, H=260
  arithCanvas.width=W*dpr; arithCanvas.height=H*dpr; ctx.setTransform(dpr,0,0,dpr,0,0)
  ctx.clearRect(0,0,W,H)

  const b=parseInt(arithB.value); arithBVal.textContent=b
  const A=(arithA.value||'0').toUpperCase()
  const B=(arithC.value||'0').toUpperCase()
  const op=arithOp.value

  const digsA=[...A].reverse().map(ch=>mapDigits.indexOf(ch))
  const digsB=[...B].reverse().map(ch=>mapDigits.indexOf(ch))
  const nCols=Math.max(digsA.length,digsB.length)+2
  const cx=W/2, step=40, baseY=H/2+20

  ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font='18px Space Grotesk'
  // columns
  let carry=0, res=[]
  for(let i=0;i<nCols;i++){
    let a=digsA[i]??0, c=digsB[i]??0
    if(a<0||a>=b||c<0||c>=b) continue
    let val=0
    if(op==='add'){ val=a+c+carry }
    else { // mul: multiply by single-digit? do full? keep simple: multiply columns with B as small
      val=(a*(digsB[0]??0)) + carry
    }
    const digit=val%b, newCarry=Math.floor(val/b)
    res.push(digit)
    // draw digits
    const x=cx+(i-(nCols-1)/2)*step
    ctx.fillStyle='#cfe2ff'; if(digsA[i]!=null) ctx.fillText(mapDigits[digsA[i]],x,baseY-50)
    ctx.fillStyle='#aee7ff'; if(digsB[i]!=null) ctx.fillText((op==='add'?'+ ':'× ')+mapDigits[digsB[i]],x,baseY-20)
    ctx.fillStyle='#ffd7aa'; ctx.fillText(mapDigits[digit],x,baseY+28)

    // carry bubble
    if(newCarry>0){
      const k=(performance.now()/1000)%1
      ctx.beginPath(); ctx.fillStyle='rgba(110,231,255,.22)'
      ctx.arc(x, baseY-78-6*Math.sin(k*Math.PI*2), 11, 0, Math.PI*2); ctx.fill()
      ctx.fillStyle='#aee7ff'; ctx.font='12px Space Grotesk'; ctx.fillText(String(newCarry),x,baseY-78)
    }
    carry=newCarry
  }
  // show base
  ctx.fillStyle='#eaf1ff'; ctx.font='16px Space Grotesk'
  ctx.fillText(`base ${b}`, W/2, 26)
}

/* 7) last k digits -> mod b^k */
const modCanvas=document.getElementById('modCanvas'), modB=document.getElementById('modB'), modK=document.getElementById('modK'), modN=document.getElementById('modN')
function drawMod(){
  const ctx=modCanvas.getContext('2d')
  const dpr=Math.min(devicePixelRatio||1,2), W=modCanvas.clientWidth||720, H=200
  modCanvas.width=W*dpr; modCanvas.height=H*dpr; ctx.setTransform(dpr,0,0,dpr,0,0)
  ctx.clearRect(0,0,W,H)

  const b=clamp(parseInt(modB.value||10),2,16), k=clamp(parseInt(modK.value||3),1,8)
  modB.value=b; modK.value=k
  const n=parseInt(modN.value||0)
  const nStr=toBaseStrBig(BigInt(n),b)
  const last=nStr.slice(-k)
  ctx.textAlign='center'; ctx.textBaseline='middle'
  ctx.font='18px Space Grotesk'; ctx.fillStyle='#eaf1ff'
  ctx.fillText(`${n}_{10} = ${nStr}_{${b}}`, W/2, 40)
  // lock
  const cx=W/2, cy=H/2+20
  ctx.fillStyle='rgba(110,231,255,.15)'; ctx.fillRect(cx-140,cy-26,280,52)
  ctx.fillStyle='#aee7ff'; ctx.fillText(`last ${k} digit(s): ${last || '0'}`, cx, cy)
  ctx.font='14px Space Grotesk'; ctx.fillStyle='#c1cced'
  ctx.fillText(`This determines n mod ${b}^${k}`, cx, H-28)
}

/* 8) infinite carry …999 + 1 */
const infCarry=document.getElementById('infCarry')
function drawInfCarry(){
  const ctx=infCarry.getContext('2d')
  const dpr=Math.min(devicePixelRatio||1,2), W=infCarry.clientWidth||720, H=260
  infCarry.width=W*dpr; infCarry.height=H*dpr; ctx.setTransform(dpr,0,0,dpr,0,0)
  ctx.clearRect(0,0,W,H)

  const n=22, cx=W/2, cy=H/2
  const t=(performance.now()/1000)%3
  const idx=Math.floor((t/3)*n)

  ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font='28px Space Grotesk'
  for(let i=0;i<n;i++){
    const x=cx+(i-n/2)*26
    const turned = i<=idx
    ctx.fillStyle=turned?'#a8ffde':'#eaf1ff'
    ctx.fillText(turned?'0':'9',x,cy)
  }
  ctx.font='20px Space Grotesk'; ctx.fillStyle='#ffd6a8'
  ctx.fillText('+ 1', cx-(n/2)*26-36, cy)
  ctx.font='16px Space Grotesk'; ctx.fillStyle='#c1cced'
  ctx.fillText('…9999 + 1  =  …0000  (10-adic)', W/2, H-30)
}

/* 10/12) p-adic geometric series closeness */
const pSeries=document.getElementById('pSeries'), pVal=document.getElementById('pVal')
function drawPSeries(){
  const ctx=pSeries.getContext('2d')
  const dpr=Math.min(devicePixelRatio||1,2), W=pSeries.clientWidth||720, H=200
  pSeries.width=W*dpr; pSeries.height=H*dpr; ctx.setTransform(dpr,0,0,dpr,0,0)
  ctx.clearRect(0,0,W,H)
  const p=clamp(parseInt(pVal.value||2),2,11); pVal.value=p

  // partial sums S_k = (p^{k+1}-1)/(p-1)
  // distance to limit L = 1/(1-p) is |S_k - L|_p = |p^{k+1}/(1-p)|_p = p^{-(k+1)}
  const cx=W/2, baseY=H/2+28, barW=W-160
  const t=(performance.now()/1000)%1
  ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font='14px Space Grotesk'
  for(let k=0;k<8;k++){
    const size=Math.pow(p, -(k+1))
    const w=barW*size
    const x=cx-w/2, y=baseY- k*18
    ctx.fillStyle='rgba(110,231,255,.18)'; ctx.fillRect(x,y-8,w,16)
    ctx.fillStyle='#aee7ff'; ctx.fillText(`|S_${k} - L|_${p} = ${p}^(-${k+1})`, cx, y)
  }
  ctx.fillStyle='#eaf1ff'; ctx.font='16px Space Grotesk'
  ctx.fillText(`Geometric: 1 + ${p} + ${p}^2 + … → 1/(1-${p}) in the ${p}-adics`, W/2, 26)
}

/* resize + animate */
function tick(){
  drawCarry(); drawRuler(); drawDiv(); drawFrac(); drawArith(); drawMod(); drawInfCarry(); drawPSeries();
  requestAnimationFrame(tick)
}
['input','change'].forEach(ev=>{
  carryBase.addEventListener(ev,drawCarry)
  rulerBase.addEventListener(ev,drawRuler)
  rulerDigits.addEventListener(ev,drawRuler)
  divN.addEventListener(ev,drawDiv)
  divB.addEventListener(ev,drawDiv)
  fracIn.addEventListener(ev,drawFrac)
  fracB.addEventListener(ev,drawFrac)
  arithA.addEventListener(ev,drawArith)
  arithC.addEventListener(ev,drawArith)
  arithB.addEventListener(ev,drawArith)
  arithOp.addEventListener(ev,drawArith)
  modB.addEventListener(ev,drawMod)
  modK.addEventListener(ev,drawMod)
  modN.addEventListener(ev,drawMod)
  pVal.addEventListener(ev,drawPSeries)
})
tick()
</script>

<!-- MathJax v3 (LaTeX rendering) -->
<script>
window.MathJax={tex:{inlineMath:[['\\(','\\)']],displayMath:[['\\[','\\]']]},svg:{fontCache:'global'}}
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" defer></script>
</body>
</html>
